//? #version 430
#ifndef INCLUDE_NNS_GLSL
#define INCLUDE_NNS_GLSL
//?#include "../common/constants.comp"
//?#include "../common/buffers.comp"

uvec3 getBinCoord(vec4 position) {
	position.xyz -= boundaryMin;
	uvec3 bin3D = uvec3(position / binSize);
	bin3D.x = max( min(bin3D.x, binMax.x -1), 0);
	bin3D.y = max( min(bin3D.y, binMax.y -1), 0);
	bin3D.z = max( min(bin3D.z, binMax.z -1), 0);
	return bin3D;
}

uint getBinIndexFromCoord(uvec3 coord) {
	return (coord.z * binMax.x * binMax.y) + (coord.y * binMax.x) + coord.x;
}   

uint getBinIndex(vec4 position) {
	uvec3 bin3D = getBinCoord(position);
    return getBinIndexFromCoord(bin3D);
}

uvec3 getBinCoordFromIndex(uint index) {
	uint z = index / (binMax.x * binMax.y);
	index -= (z * binMax.x * binMax.y);
	uint y = index / binMax.x;
	uint x = index % binMax.x;
	return uvec3(x, y, z);
}

#define OVERNNS {\
uvec3 binIndexVec = getBinCoordFromIndex(particles[i].binIndex);\
ivec3 minBound = max(ivec3(binIndexVec) - 1, ivec3(0));\
ivec3 maxBound = min(ivec3(binIndexVec) + 1, ivec3(binMax) - 1);\
for (int z = minBound.z; z <= maxBound.z; z++) {\
    for (int y = minBound.y; y <= maxBound.y; y++) {\
        for (int x = minBound.x; x <= maxBound.x; x++) {\
            uint cindex = getBinIndexFromCoord(uvec3(x, y, z));\
            if (bins[cindex].count == 0) continue;\
            uint ns = bins[cindex].count;\
            uint st = bins[cindex].sum - ns;\
            for (uint k = st; k < st + min(ns, MAXNN); k++) {\
                uint j = particles[k].newIndex;\
                if (j == i || j >= numParticles) continue;

#define OVERNNS_END }}}}}


#define OVERNNS_I {\
uvec3 binIndexVec = getBinCoordFromIndex(particles[i].binIndex);\
ivec3 minBound = max(ivec3(binIndexVec) - 1, ivec3(0));\
ivec3 maxBound = min(ivec3(binIndexVec) + 1, ivec3(binMax) - 1);\
for (int z = minBound.z; z <= maxBound.z; z++) {\
    for (int y = minBound.y; y <= maxBound.y; y++) {\
        for (int x = minBound.x; x <= maxBound.x; x++) {\
            uint cindex = getBinIndexFromCoord(uvec3(x, y, z));\
            if (bins[cindex].count == 0) continue;\
            uint ns = bins[cindex].count;\
            uint st = bins[cindex].sum - ns;\
            for (uint k = st; k < st + min(ns, MAXNN); k++) {\
                uint j = particles[k].newIndex;\
                if (j >= numParticles) continue;

/*
#define OVERNNS {uvec3 binIndexVec = getBinCoordFromIndex(particles[i].binIndex); \
for (int z = int(binIndexVec.z) - 1; z <= int(binIndexVec.z) + 1; z++) { \
	for (int y = int(binIndexVec.y) - 1; y <= int(binIndexVec.y) + 1; y++) { \
		for (int x = int(binIndexVec.x) - 1; x <= int(binIndexVec.x) + 1; x++) { \
			if (x < 0 || y < 0 || z < 0   ||    x >= binMax.x || y >= binMax.y || z >= binMax.z) continue; \
			uint cindex = getBinIndexFromCoord(uvec3(x, y, z)); \
			if (bins[cindex].count == 0) continue; \
			uint ns = bins[cindex].count; \
			uint st = bins[cindex].sum - bins[cindex].count; \
			for (uint k = st; k < st+min(ns, MAXNN); k++) { \
				uint j = particles[k].newIndex; \
				if (j == i || j >= numParticles) continue;
				//do something

#define OVERNNS_END }}}}}

#define OVERNNS_I {uvec3 binIndexVec = getBinCoordFromIndex(particles[i].binIndex); \
for (int z = int(binIndexVec.z) - 1; z <= int(binIndexVec.z) + 1; z++) { \
	for (int y = int(binIndexVec.y) - 1; y <= int(binIndexVec.y) + 1; y++) { \
		for (int x = int(binIndexVec.x) - 1; x <= int(binIndexVec.x) + 1; x++) { \
			if (x < 0 || y < 0 || z < 0   ||    x >= binMax.x || y >= binMax.y || z >= binMax.z) continue; \
			uint cindex = getBinIndexFromCoord(uvec3(x, y, z)); \
			if (bins[cindex].count == 0) continue; \
			uint ns = bins[cindex].count; \
			uint st = bins[cindex].sum - bins[cindex].count; \
			for (uint k = st; k < st+min(ns, MAXNN); k++) { \
				uint j = particles[k].newIndex; \
				if (j >= numParticles) continue;

*/

#endif// INCLUDE_BUFFERS_HLSL