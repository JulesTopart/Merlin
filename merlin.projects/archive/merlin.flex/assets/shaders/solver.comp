#version 450

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#include "common.glsl"
#include "constants.glsl"

uniform float speed;
uniform uint numParticles;

// --- SPH_Kernels ---
//Computed the poly6 scalar smoothing kernel
float poly6(vec3 r)
{
	float rBar = length(r);

	if (rBar < EPSILON || rBar > H) {
		return EPSILON;
	}

	// (315 / (64 * PI * h^9)) * (h^2 - |r|^2)^3
	if (H9 < EPSILON) {
		return 0.0f;
	}
	float A = 1.566681471061f / H9;
	float B = (H2) - (rBar * rBar);

	return A * (B * B * B);
}

//Computes the spiky smoothing kernel gradient*/
vec3 spiky(vec3 r)
{
	float rBar = length(r);

	if (rBar < EPSILON || rBar > H) {
		return vec3(0.0f, 0.0f, 0.0f);
	}

	// (45 / (PI * h^6)) * (h - |r|)^2 * (r / |r|)
	if (H6 < EPSILON) {
		return vec3(0.0f, 0.0f, 0.0f);
	}
	float A = 14.323944878271f / H6;
	float B = (H - rBar);
	vec3 outGrad = A * (B * B) * (r / (rBar + EPSILON));
	return outGrad;
}

// Computes the viscosity Laplacian
float viscosityLaplacianKernel(float rLength)
{
	if (rLength <= H)
	{
		return VISC_LAPLACE_COEFFICIENT * (H - rLength);
	}
	return 0.0;
}

// Computes the Pressure Laplacian
float lapl_pse(vec3 pi, vec3 pj, float hi) {
	float r = length(pi - pj);

	float h2 = hi*hi;
	float h4 = h2*h2;
	float w2_pse  = +4./(h4*M_PI)*exp(-r*r/(h2));

	return w2_pse;
}





// --- SPH Routines ---
// SPH_Density
float calculateDensity(uint gid, vec3 pposition) {
	float density = 0.0;

	for (uint j = 0; j < numParticles; j++) {
		if (j == gid) continue;

		Particle pj = particles[j];
		vec3 diff = vec3(pposition) - vec3(pj.position);
		float rSquared = dot(diff, diff);

		density += particleMass * poly6(diff);
	}
	return density;
}

// SPH_Density_neighbor
float calculateDensityN(uint gid, vec3 pposition) {
	float density = 0.0;

	ivec3 binIndexVec = ivec3(floor(float(binResolution) * particles[gid].position * scale) / (2.0) );

	for (uint z = binIndexVec.z - (binIndexVec.z > 0 ? 1 : 0); z <= binIndexVec.z + 1; z++) {
		for (uint y = binIndexVec.y - (binIndexVec.y > 0 ? 1 : 0); y <= binIndexVec.y + 1; y++) {
			for (int x = int(binIndexVec.x) - (binIndexVec.x > 0 ? 1 : 0); x <= binIndexVec.x + 1; x++) {	

				if(x < 0 || y < 0 || z < 0) continue;
				if(x > binResolution || y > binResolution || z > binResolution) continue;

				uint currentBinIndex = (z * binResolution * binResolution) + (y * binResolution) + x;

				for(int k = 0; k < bins[currentBinIndex].count; k++){
					uint j = bins[currentBinIndex].indices[k];

					if (j == gid) continue;

					Particle pj = particles[j];
					vec3 diff = vec3(pposition) - vec3(pj.position);
					float rSquared = dot(diff, diff);

					density += particleMass * poly6(diff);
				}

			}
		}
	}

	return density;
}


// SPH_Lambda
float computeLambda(uint gid, vec3 pposition, float density) {
	float C_i = (density * INV_REST_DENSITY) - 1.0f;
	vec3 gradient = vec3(0.0);
	float gv_sLengths = 0;

	for (uint j = 0; j < numParticles; j++) {
		if (j == gid) continue;
		

		Particle pj = particles[j];
		vec3 diff = vec3(pposition) - vec3(pj.position);
		if (length(diff) > H) continue;
		float rSquared = dot(diff, diff);

		vec3 sp = spiky(diff);
		gradient += sp;
		float lsp = length(INV_REST_DENSITY * -sp);
		gv_sLengths += lsp * lsp;

	}

	float gv_iLength = length(INV_REST_DENSITY * gradient);
	float gradientSum =  (gv_iLength*gv_iLength) + gv_sLengths;


	if (gradientSum == 0.0f) {
		gradientSum = EPSILON;
    }

	return -(C_i / ((gradientSum + relaxation))); //relaxation
}


// SPH_Lambda_neighbor
float computeLambdaN(uint gid, vec3 pposition, float density) {
	ivec3 binIndexVec = ivec3(floor(float(binResolution) * particles[gid].position * scale) / (2.0) );

	float C_i = (density * INV_REST_DENSITY) - 1.0f;
	vec3 gradient = vec3(0.0);
	float gv_sLengths = 0;


	for (uint z = binIndexVec.z - (binIndexVec.z > 0 ? 1 : 0); z <= binIndexVec.z + 1; z++) {
		for (uint y = binIndexVec.y - (binIndexVec.y > 0 ? 1 : 0); y <= binIndexVec.y + 1; y++) {
			for (int x = int(binIndexVec.x) - (binIndexVec.x > 0 ? 1 : 0); x <= binIndexVec.x + 1; x++) {	

				if(x < 0 || y < 0 || z < 0) continue;
				if(x > binResolution || y > binResolution || z > binResolution) continue;

				uint currentBinIndex = (z * binResolution * binResolution) + (y * binResolution) + x;

				for(int k = 0; k < bins[currentBinIndex].count; k++){
					uint j = bins[currentBinIndex].indices[k];

					if (j == gid) continue;
		

					Particle pj = particles[j];
					vec3 diff = vec3(pposition) - vec3(pj.position);
					if (length(diff) > H) continue;
					float rSquared = dot(diff, diff);

					vec3 sp = spiky(diff);
					gradient += sp;
					float lsp = length(INV_REST_DENSITY * -sp);
					gv_sLengths += lsp * lsp;
				}
			}
		}
	}

	float gv_iLength = length(INV_REST_DENSITY * gradient);
	float gradientSum =  (gv_iLength*gv_iLength) + gv_sLengths;


	if (gradientSum == 0.0f) {
		gradientSum = EPSILON;
    }

	return -(C_i /((gradientSum + relaxation))); //lamdba Incompressibility
}



//Compute position deltas
vec3 computePositionDelta(uint i) {
	vec3 posDelta = vec3(0.0f, 0.0f, 0.0f);

	for (uint j = 0; j < numParticles; j++) {
		if(i == j) continue;
		float lambda_i = particles[i].lambda;
		float lambda_j = particles[j].lambda;

		// Introduce the artificial pressure corrector:

		vec3 r = particles[i].new_position - particles[j].new_position;
		vec3 gradient = spiky(r);
		float n = poly6(r);

		// For the point delta Q, we use p_j->posStar as a starting point, and
		// add an offset value:

		float offset = (0.3f * H);
		vec3 deltaQ = particles[j].new_position + vec3(offset, offset, offset);
		float d = poly6(deltaQ);
		float nd = abs(d) <= EPSILON ? 0.0f : n / d;

		// Finally, compute the artificial pressure correction:
		float lambda_corr = -pressureStrength * pow(nd, pressurePower);
		posDelta += ((lambda_i + lambda_j + lambda_corr) * gradient);


	}

	vec3 final = INV_REST_DENSITY * posDelta ;
	return final;
}

//Compute position deltas w neigbor
vec3 computePositionDeltaN(uint i) {
	vec3 posDelta = vec3(0.0f, 0.0f, 0.0f);

	ivec3 binIndexVec = ivec3(floor(float(binResolution) * particles[i].position * scale) / (2.0) );

	for (uint z = binIndexVec.z - (binIndexVec.z > 0 ? 1 : 0); z <= binIndexVec.z + 1; z++) {
		for (uint y = binIndexVec.y - (binIndexVec.y > 0 ? 1 : 0); y <= binIndexVec.y + 1; y++) {
			for (int x = int(binIndexVec.x) - (binIndexVec.x > 0 ? 1 : 0); x <= binIndexVec.x + 1; x++) {	

				if(x < 0 || y < 0 || z < 0) continue;
				if(x > binResolution || y > binResolution || z > binResolution) continue;

				uint currentBinIndex = (z * binResolution * binResolution) + (y * binResolution) + x;

				for(uint k = 0; k < bins[currentBinIndex].count; k++){
					uint j = bins[currentBinIndex].indices[k];

					if (j == i || j == 0) continue;
		
					float lambda_i = particles[i].lambda;
					float lambda_j = particles[j].lambda;

					// Introduce the artificial pressure corrector:

					vec3 r = particles[i].new_position - particles[j].position; //This seems to be related to elastisity
					vec3 gradient = spiky(r);
					float n = poly6(r);

					// For the point delta Q, we use p_j->posStar as a starting point, and
					// add an offset value:

					float offset = (0.2f * H);
					vec3 deltaQ = particles[j].new_position + vec3(offset, offset, offset);
					float d = poly6(deltaQ);
					float nd = abs(d) <= EPSILON ? 0.0f : n / d;

					// Finally, compute the artificial pressure correction:
					float lambda_corr = -pressureStrength * pow(nd, pressurePower);
					posDelta += ((lambda_i + lambda_j + lambda_corr) * gradient);

				}
			}
		}
	}
	vec3 final = INV_REST_DENSITY * posDelta;
	return final;
}



//calculate Viscosity
vec3 constrainVelocityN(uint gid, vec3 velocity) {
	ivec3 binIndexVec = ivec3(floor(float(binResolution) * particles[gid].position * scale) / (2.0) );
	uint currentBinIndex = (binIndexVec.z * binResolution * binResolution) + (binIndexVec.y * binResolution) + binIndexVec.x;



	for (uint z = binIndexVec.z - (binIndexVec.z > 0 ? 1 : 0); z <= binIndexVec.z + 1; z++) {
		for (uint y = binIndexVec.y - (binIndexVec.y > 0 ? 1 : 0); y <= binIndexVec.y + 1; y++) {
			for (int x = int(binIndexVec.x) - (binIndexVec.x > 0 ? 1 : 0); x <= binIndexVec.x + 1; x++) {	

				if(x < 0 || y < 0 || z < 0) continue;
				if(x > binResolution || y > binResolution || z > binResolution) continue;

				uint currentBinIndex = (z * binResolution * binResolution) + (y * binResolution) + x;

				for(uint k = 0; k < bins[currentBinIndex].count; k++){
					uint j = bins[currentBinIndex].indices[k];
						if (j == gid) continue;

						vec3 dij = particles[gid].new_position - particles[j].new_position;
						vec3 vij = particles[j].velocity - particles[gid].velocity;
						
						float dynamicViscosity = 5.0;//max(min(artificialViscosity, artificialViscosity * (particles[gid].temperature / 453.15)), 10*artificialViscosity);
						velocity += dynamicViscosity * viscosityLaplacianKernel(length(dij)) * (vij);
				}
			}
		}
	}

	if(particles[gid].position.z < H/2.0){
		velocity -= floorFriction * velocity;
	}

	//velocity *= max(min((particles[gid].temperature / (453.15)),0.0),1.0);
	return velocity;
}


//calculate Temperature
float computeTemperatureN(uint gid) {
	ivec3 binIndexVec = ivec3(floor(float(binResolution) * particles[gid].position * scale) / (2.0) );
	uint currentBinIndex = (binIndexVec.z * binResolution * binResolution) + (binIndexVec.y * binResolution) + binIndexVec.x;

	const float Ti = particles[gid].temperature;
	float temperatureDelta = 0.0;
	
	for (uint z = binIndexVec.z - (binIndexVec.z > 0 ? 1 : 0); z <= binIndexVec.z + 1; z++) {
		for (uint y = binIndexVec.y - (binIndexVec.y > 0 ? 1 : 0); y <= binIndexVec.y + 1; y++) {
			for (int x = int(binIndexVec.x) - (binIndexVec.x > 0 ? 1 : 0); x <= binIndexVec.x + 1; x++) {	

				if(x < 0 || y < 0 || z < 0) continue;
				if(x > binResolution || y > binResolution || z > binResolution) continue;

				uint currentBinIndex = (z * binResolution * binResolution) + (y * binResolution) + x;

				for(uint k = 0; k < bins[currentBinIndex].count; k++){
					uint j = bins[currentBinIndex].indices[k];
						if (j == gid) continue;

						vec3 dij = particles[gid].new_position - particles[j].new_position;

						float Tj = particles[j].temperature;
						float rhoj = particles[j].density;
					
						float w2_pse = viscosityLaplacianKernel(dij.length);
						float lambda = (kPLA / (CpPLA * particles[gid].density));
						temperatureDelta += lambda * (Tj-Ti) * w2_pse * dt;

				}
			}
		}
	}

	if(particles[gid].position.z < H/2.0){
		temperatureDelta += kPlateau * (floorTemperature - Ti) * dt;
	}
	temperatureDelta += kAmbient*(ambientTemperature - Ti) * dt;
	return temperatureDelta;
}


// SPH_BoundaryForce
vec3 calculateBoundaryForce(uint gid) {
	vec3 force = vec3(0);
	float distanceFromWall = boundaryRepulsionDistance * 2;

	for (int i = 0; i < 3; i++) {
		//X+
		float distanceFromWall = abs(particles[gid].position[i] - boundaryMax[i]);
		if (distanceFromWall < boundaryRepulsionDistance) {
			float distanceFromWall = particles[gid].position[i] - boundaryMax[i];
			distanceFromWall = abs(distanceFromWall);
			force[i] -= boundaryRepulsionForce * exp(((-1.0) * distanceFromWall) / boundaryRepulsionDistance);
		}
		//X-
		distanceFromWall = abs(particles[gid].position[i] - boundaryMin[i]);
		if (distanceFromWall < boundaryRepulsionDistance) {
			float distanceFromWall = particles[gid].position[i] - boundaryMin[i];
			distanceFromWall = abs(distanceFromWall);
			force[i] += boundaryRepulsionForce * exp(((-1.0) * distanceFromWall) / boundaryRepulsionDistance);
		}
	}
	return force;
}


vec3 clampToBoundaries(vec3 position)
{
	vec3 correctedPosition = position;
	for (int i = 0; i < 3; i++)
	{
		if ((correctedPosition[i] - H*0.3) * scale  < boundaryMin[i])
		{
			correctedPosition[i] = (boundaryMin[i]/scale) + ((H*0.3) + EPSILON);

		}
		else if ((correctedPosition[i] + H*0.3) * scale  > boundaryMax[i])
		{
			correctedPosition[i] =  (boundaryMax[i]/scale) - ((H*0.3) + EPSILON);
		}
	}

	return correctedPosition;
}




void XPBDSolve(uint gid, uint simStep) {
	Particle p = particles[gid];
	if(simStep == 0){ //Integrate
		//Calculate external force
		vec3 externalForce = vec3(0,0,-G*particleMass/scale);

		//Predict position
		p.velocity = p.velocity + (externalForce / particleMass) * dt * speed;
		p.new_position = clampToBoundaries(p.position + p.velocity * dt * speed);
		

	}else if(simStep == 1){ //Neighbor search

		ivec3 binIndexVec = ivec3(floor(float(binResolution) * particles[gid].position * scale) / (2.0) );
		uint currentBinIndex = (binIndexVec.z * binResolution * binResolution) + (binIndexVec.y * binResolution) + binIndexVec.x;
		uint preValue = max(min(atomicAdd(bins[currentBinIndex].count, 1),31),0);
		atomicAdd(bins[currentBinIndex].indices[preValue], gid);
	}
	//Solver iteration
	else if(simStep == 2){ //Compute lambda
		//p.density = calculateDensity(gid, p.new_position);
		p.density = calculateDensityN(gid, p.new_position);
		
		
		//p.lambda = computeLambda(gid, p.new_position, p.density); 
		p.lambda = computeLambdaN(gid, p.new_position, p.density); 
	}else if (simStep == 3){ //position delta
		//vec3 positionDelta = computePositionDelta(gid);
		
		vec3 positionDelta = computePositionDeltaN(gid);
		p.new_position = clampToBoundaries(p.new_position + positionDelta);
	}else if(simStep == 4){ //Apply changes
		p.velocity = (p.new_position - p.position) / (dt*speed);
		p.position = p.new_position;
		p.temperature += computeTemperatureN(gid);
		p.velocity = constrainVelocityN(gid, p.velocity);

		
	}
	particles[gid] = p;
	//end
}


uniform uint stage;
uniform vec3 sourcePos;
// XPBD_Main
void main() {
	uint gid = gl_GlobalInvocationID.x;
	if (gid >= numParticles){ 
		if(particles[gid].new_position == vec3(0.0)){ //Spawing a new particle in the nozzle
			particles[gid].position += sourcePos/scale;
		}
	}

	XPBDSolve(gid, stage);
}
