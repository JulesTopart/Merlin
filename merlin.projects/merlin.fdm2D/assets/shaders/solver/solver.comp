#version 430

#pragma once
#include "../common/uniforms.comp"
#include "../common/constants.comp"
#include "../common/buffers.comp"
#include "../common/colors.comp"
#include "../common/nns.comp"
#include "sph.kernels.comp" 
#include "nozzleSDF.comp" 
#include "constraint.comp" 


layout (local_size_x = PTHREAD) in;
void SolveDEM(uint i, uint simStep);
void NNS(uint i, uint simStep);

uniform uint stage;
uniform float drumSpeed = 10;
// XPBD_Main
void main() {
	uint i = gl_GlobalInvocationID.x;
	if (i >= numParticles) return;
	NNS(i, stage);
	if(B_Phase(i) != BOUNDARY)	SolveDEM(i, stage);
}

void NNS(uint i, uint simStep){
	if(simStep == 0){ //Bin sorting
		uint bin = B_BinIndex(i) = getBinIndex(Xi);
		atomicAdd(bins[bin].count, 1);
		ssbo_cpy_position[i] = ssbo_position[i];
		ssbo_cpy_pposition[i] = ssbo_pposition[i];
		ssbo_cpy_velocity[i] = ssbo_velocity[i];
		ssbo_cpy_density[i] = ssbo_density[i];
		ssbo_cpy_pressure[i] = ssbo_pressure[i];
		ssbo_cpy_temperature[i] = ssbo_temperature[i];
		ssbo_cpy_meta[i] = ssbo_meta[i];

		return;
	}else if(simStep == 1){//Sort particle indices
		uint newID = atomicAdd(bins[ssbo_cpy_meta[i].y].index, -1) -1;

		ssbo_position[newID]  = ssbo_cpy_position[i];
		ssbo_pposition[newID] = ssbo_cpy_pposition[i];
		ssbo_velocity[newID]  = ssbo_cpy_velocity[i];
		ssbo_density[newID]   = ssbo_cpy_density[i];
		ssbo_pressure[newID]    = ssbo_cpy_pressure[i];
		ssbo_temperature[newID]  = ssbo_cpy_temperature[i];
		ssbo_meta[newID]      = ssbo_cpy_meta[i];
		ssbo_meta[ssbo_meta[newID].z].z = newID;
		return;
	}
}



void SolveDEM(uint i, uint simStep) {
	
	if(simStep == 2){
		computeDensityPressure(i);
		return;
	}else if(simStep == 3){
		float rhoi = Rhoi;
		vec2 fpress = vec2(0);
		vec2 fvisc = vec2(0);
		vec2 fgrav = vec2(0,-g*.5) * particleMass / rhoi;
		vec2 position = Xi;

		OVERNNS
			vec2 rij = Rij;
			if(length(rij) >= H || length(rij) <= 1e-6) continue;
			if(i != j){
				fpress += -normalize(rij) * particleMass * (Pi + Pj) / (2.0f * Rhoj) * spiky(rij);
				//fvisc -= 3*artificialViscosityMultiplier * particleMass * Vij / Rhoj * viscosityLaplacianKernel(rij);
			}
		OVERNNS_END


		

		vec2 fnozzle = vec2(0);
		float dist = nozzleSDF(Xi) ;
		if(dist <= -particleRadius){
		    const float eps = 0.0001; // or some other value
			const vec2 h = vec2(eps, 0);
			vec2 p = Xi;
			vec2 normal = normalize( vec2(nozzleSDF(Xi+h.xy) - nozzleSDF(Xi-h.xy), nozzleSDF(Xi+h.yx) - nozzleSDF(Xi-h.yx) ) );
			fnozzle -= 200000.0*normal * min(((dist-particleRadius)), 0.0);
			//Ti += 0.04*(500 - Ti)*dt;
		}


		if(dist < particleRadius*1.5)Ti += dt*1.5 * (275 + 215 - Ti);
		if(length(Xi) > 150) Ti += dt*1.5 * max(Xi.y - boundaryMin.y,0) * (275 + 25 - Ti);//fan

		Ti += min(computeTemperatureDelta(i)*dt, 1.0);
		Vi += dt * (fpress + fgrav + fvisc + fnozzle)/rhoi;

		Xi += dt * Vi;

		//Vi += solveFloorCollision(i)/dt;
		Xi += solveFloorCollision(i);


		return;

	}else if(simStep == 4){
		vec2 xsphSum = vec2(0);

		if(Xi.y < boundaryMin.y + 1.5*particleRadius){
			Vi.x += (1000-Vi.x);
		}

		vec2 position = Xi;
		OVERNNS
			if(length(Rji) < 1e-6 || i == j) continue;
			float Wij = poly6(Rji);
			xsphSum -= XSPH * Vij * Wij * Rhoj;
		OVERNNS_END
		Vi -= xsphSum;
		Vi = normalize(Vi) * min(length(Vi), 200000*dt);

		xi = Xi;
		return;
	}

}



