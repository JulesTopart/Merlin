//? #version 430
#ifndef INCLUDE_SPH_KERNELS_GLSL
#define INCLUDE_SPH_KERNELS_GLSL

//?#include "../common/uniforms.comp"
//?#include "../common/constants.comp"
//?#include "../common/buffers.comp"

// --- Kernels ---
// Kernel Functions Precomputed Constants
#define H smoothingRadius // Kernel radius
#define H2 pow(H,2)
#define H3 pow(H,3)
#define H5 pow(H,5)
#define H6 pow(H,6)
#define H9 pow(H,9)

#define M_PI 3.14159265358979323846
#define PI_FAC 0.454728408833987

#define KERNEL_K (40.0 / (7.0 * (M_PI*H*H)))
#define KERNEL_L (240.0 / (7.0 * (M_PI*H*H)))
#define SPIKY_KERNEL_CONST (10.0 / (M_PI * H * H))


float cubicKernel2D(vec2 r) {
  float result = 0;
  float q = length(r) / H;
  if (q <= 1.0){
    float q2 = q*q;
    float q3 = q2*q;
    if (q <= 0.5)
      result = KERNEL_K * (6.0*q3 - 6.0*q2 + 1.0);
    else
      result = KERNEL_K * (2.0*pow(1.0 - q, 3));
  }
  return result;
}
 
// Gradient of cubic spline kernel 2D 
vec2 cubicKernel2D_Gradient(vec2 r){
  vec2 result = vec2(0,0);
  float rl = length(r);
  float q = rl / H;
  if (q <= 1.0){
    if (rl > 1.0e-6){
      vec2 gradq = r * (1.0 / (rl*H));
      if (q <= 0.5){
        result = gradq * (KERNEL_L*q*(3.0*q - 2.0)) ;
      }
      else {
        float factor = (1.0 - q) * (1.0 - q);
        result = gradq * (-KERNEL_L*factor) ;
      }
    }
  }
  return result;
}


vec2 spikyGradient(vec2 r) {
  vec2 result = vec2(0,0);
  float rl = length(r);
  float q = rl / H;
  if (q < 1.0 && rl > 1.0e-6) {
    float coeff = -SPIKY_KERNEL_CONST * (H - rl);
    result = r * (coeff / rl);
  }
  return result;
}

#endif