//? #version 430
#ifndef INCLUDE_CONSTRAINTS_GLSL
#define INCLUDE_CONSTRAINTS_GLSL

//?#include "../common/uniforms.comp"
//?#include "../common/constants.comp"
//?#include "../common/buffers.comp"
//?#include "../common/nns.comp"
//?#include "sph.kernels.comp" 

vec2 solveFloorCollision(uint i){
	vec2 correctedPosition = particles[i].pposition;
	for (int i = 0; i < 2; i++){
		if (correctedPosition[i] - particleRadius <= boundaryMin[i] ){
			correctedPosition[i] = (boundaryMin[i]) + particleRadius;
		}
		else if (correctedPosition[i] + particleRadius >= boundaryMax[i])
		{
			correctedPosition[i] =  boundaryMax[i] - particleRadius;
		}
	}

	return (correctedPosition - particles[i].pposition)/10.0;
}


float sdBox( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}
vec3 sdgBox( in vec2 p, in vec2 b )
{
    vec2 w = abs(p)-b;
    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);
    float g = max(w.x,w.y);
    vec2  q = max(w,0.0);
    float l = length(q);
    return vec3(   (g>0.0)?l  :g,
                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));
}

//position and predicted position
void clampToDomain(inout vec2 position, inout vec2 pposition){
	vec2 delta = pposition - position;
	vec3 sqg = sdgBox(pposition, halfdomain);
	float dist = sqg.x + particleRadius/2.0;

	if(dist < 0.0) return; //inside the domain

	vec2 maxPos = pposition - sqg.yz * dist;  
	float dotProduct = dot(delta, sqg.yz);
    vec2 reflection = delta - (sqg.yz * 2 * dotProduct);
      
    pposition = maxPos;
    position = pposition + reflection;
}

float computeDensity(uint i) {
	float density = particleMass * densityKernel(vec2(0.0));
	Particle pi = particles[i];

	OVERNNS
		Particle pj = particles[j];
		float dist = distance(pi.position, pj.position);
		if(dist > H) continue;
		density += (1.0/dt) * pj.mass * densityKernel(dist); //Fluid, solid or boundary (mass and pseudo mass stored at the same location : See init.comp)
	OVERNNS_END
	return  density;
}



float computeLambda(uint i) {
    float rho0 = REST_DENSITY;
    float sumGradCj = 0;
    vec2 gradCi = vec2(0);
    float density = 0.0;
    
    OVERNNS_I
        if(particles[j].phase != FLUID || distance( particles[i].pposition, particles[j].pposition) > H) continue;

		vec2 dist = particles[i].pposition - particles[j].pposition;
		if(length(dist) == 0) dist = vec2(1.0); //just in case two particle are in the same spot
		vec2 gradCj = densityGradientKernel(dist);
		if (j == i) {
			gradCi += gradCj;
		}
		sumGradCj += dot(gradCj, gradCj);
		
		if (j != i) density += particles[j].mass * densityKernel(dist);
	OVERNNS_END
	particles[i].density = density;
    float C = max((particles[i].density / rho0) - 1.0, 0.0); //clamp pressure term to 0.0
    return -C / (sumGradCj + 1e-6);
}


//Compute position deltas w neigbor
vec2 computePressureForce(uint i) {
	vec2 force = vec2(0.0f);
	float rho0 = REST_DENSITY;
	if(particles[i].density -  REST_DENSITY < 1e-6) return force;
	OVERNNS
		if( particles[j].phase != FLUID || distance( particles[i].pposition, particles[j].pposition) > H) continue;
		vec2 dist = particles[i].pposition - particles[j].pposition;
		force -= (particles[j].mass / particles[j].density);
	OVERNNS_END
	return force;
}

//Compute position deltas w neigbor
vec2 computePositionDelta(uint i) {
	vec2 posDelta = vec2(0.0f);
	float rho0 = REST_DENSITY;
	if(particles[i].density -  REST_DENSITY < 1e-6) return posDelta;
	OVERNNS
		if( particles[j].phase != FLUID || distance( particles[i].pposition, particles[j].pposition) > H) continue;
		  vec2 dist = particles[i].pposition - particles[j].pposition;
          float sCorr = -(pressureMultiplier) * pow(pressureKernel(dist) / pressureKernel(vec2(0.3*H,0)), 4);
          vec2 dp_ij = pressureGradientKernel(dist) * ((particles[i].lambda + particles[j].lambda + sCorr  ) / rho0);
          posDelta += dp_ij;
	OVERNNS_END
	return posDelta;
}

/*DFSPH
//predict density but advecting quantities
float predictDensity(uint i) {
	
	Particle pi = particles[i];

	float deltaDensity = 0.0;
	OVERNNS
		Particle pj = particles[j];
		vec2 diff = pi.position - pj.position;
		vec2 veldiff = pi.pvelocity - pj.pvelocity;
		deltaDensity += pj.mass * dot(veldiff, cubicKernel2D_Gradient(diff)); //Fluid, solid or boundary (mass and pseudo mass stored at the same location : See init.comp)
	OVERNNS_END

	return particles[i].density + dt * deltaDensity;
}

//constant density solving
void correctDensity(uint i) {
	Particle pi = particles[i];
	float pI = kDensity * (particles[i].pdensity - REST_DENSITY)/(dt*dt);
	float rhoI = pi.density;
	vec2 velCorrection = vec2(0);
	OVERNNS
		Particle pj = particles[j];
		float rhoJ = pj.density;
		float pJ = kDensity * (pj.pdensity - REST_DENSITY)/(dt*dt);
		vec2 diff = pi.position - pj.position;
		velCorrection += pj.mass * ((pI/(rhoI*rhoI)) + (pJ/rhoJ*rhoJ)) * cubicKernel2D_Gradient(diff); //Fluid, solid or boundary (mass and pseudo mass stored at the same location : See init.comp)
	OVERNNS_END

	particles[i].pvelocity -= dt * velCorrection;
}
*/

/*
// Introduce the viscosity constraint and its gradient
float densityConstraint(float density) {
    return (density * (1.0/REST_DENSITY)) - 1.0f;
}

vec2 densityConstraintGradient(vec2 pi, vec2 pj) {
	vec2 diff = pi - pj;
	if (length(diff.xy) > H) return vec2(0.0);//neighbor too far
	return spikyGradient(diff);
}

// Introduce the viscosity constraint and its gradient
float viscosityConstraint(vec2 p_i, vec2 p_j, float d_ij) {
    return d_ij - length(p_i - p_j) - artificialViscosity * d_ij;
}

vec4 viscosityConstraintGradient(vec4 p_i, vec4 p_j) {
    vec4 p_ij = p_i - p_j;
    return normalize(p_ij);
}


float computeLambda(uint i) {
	Particle pi = particles[i];
    if(pi.density == REST_DENSITY) return 0.0;

    float rho0 = REST_DENSITY;
    float sumGradCj = 0;
    vec4 gradCi = vec4(0);
    float density = 0.0;
    
    OVERNNS_I
		Particle pj = particles[j];
        if(pj.phase != FLUID) continue;
  
		vec4 dist = pi.pposition - pj.pposition;
		vec4 gradCj = densityConstraintGradient(pi.pposition, pj.pposition);
		if (j == i) {
			gradCi += gradCj;
		}
		sumGradCj += dot(gradCj, gradCj);
		density += pj.mass * poly6(dist);
	OVERNNS_END

	particles[i].density = density;
    float C = max((density / rho0) - 1, 0.0);
    return -C / (sumGradCj + 1e-6);
}


//Compute position deltas w neigbor
vec4 computePositionDelta(uint i) {
	vec4 posDelta = vec4(0.0f);
	float rho0 = REST_DENSITY;
	Particle pi = particles[i];
	OVERNNS
		Particle pj = particles[j];
		if( pj.phase != FLUID) continue;
		  vec4 dist = pi.pposition - pj.pposition;
          float sCorr = -(pressureMultiplier) * pow(poly6(dist) / poly6(vec4(0.3*H, 0,0,0)), 4);
          vec4 dp_ij = spiky_grad(dist) * ((pi.lambda + pj.lambda  + sCorr ) / rho0);
          posDelta += dp_ij;
	OVERNNS_END
	return posDelta;
}
*/

#endif