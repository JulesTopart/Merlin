//? #version 430
#ifndef INCLUDE_CONSTRAINTS_GLSL
#define INCLUDE_CONSTRAINTS_GLSL

//?#include "../common/uniforms.comp"
//?#include "../common/constants.comp"
//?#include "../common/buffers.comp"
//?#include "../common/nns.comp"
//?#include "sph.kernels.comp" 

vec2 solveFloorCollision(uint i){
	vec2 correctedPosition = particles[i].new_position;
	for (int i = 0; i < 2; i++){
		if (correctedPosition[i] - particleRadius <= boundaryMin[i] ){
			correctedPosition[i] = (boundaryMin[i]) + particleRadius;
		}
		else if (correctedPosition[i] + particleRadius >= boundaryMax[i])
		{
			correctedPosition[i] =  boundaryMax[i] - particleRadius;
		}
	}

	return (correctedPosition - particles[i].new_position)/10.0;
}


void clampPosition(inout vec4 position){
	vec4 correctedPosition = position;
	for (int i = 0; i < 3; i++){
		if (correctedPosition[i] - particleRadius <= boundaryMin[i] )
		{
			correctedPosition[i] = (boundaryMin[i]) + particleRadius;
			//velocity[i] *= boundaryDamping;

		}
		else if (correctedPosition[i] + particleRadius >= boundaryMax[i])
		{
			correctedPosition[i] =  boundaryMax[i] - particleRadius;
			//velocity[i] *= boundaryDamping;
		}
	}

	position = correctedPosition / 6.0;
}

float computeDensity(uint i) {
	float density = particleMass * cubicKernel2D(vec2(0.0));
	Particle pi = particles[i];

	OVERNNS
		Particle pj = particles[j];
		if( pj.phase != FLUID) continue;
		vec2 diff = pi.position - pj.position;
		density += (1.0/pj.invmass)*cubicKernel2D(diff); //Fluid, solid or boundary (mass and pseudo mass stored at the same location : See init.comp)
	OVERNNS_END
	return  density;
}






/*
// Introduce the viscosity constraint and its gradient
float densityConstraint(float density) {
    return (density * (1.0/REST_DENSITY)) - 1.0f;
}

vec2 densityConstraintGradient(vec2 pi, vec2 pj) {
	vec2 diff = pi - pj;
	if (length(diff.xy) > H) return vec2(0.0);//neighbor too far
	return spikyGradient(diff);
}

// Introduce the viscosity constraint and its gradient
float viscosityConstraint(vec2 p_i, vec2 p_j, float d_ij) {
    return d_ij - length(p_i - p_j) - artificialViscosity * d_ij;
}

vec4 viscosityConstraintGradient(vec4 p_i, vec4 p_j) {
    vec4 p_ij = p_i - p_j;
    return normalize(p_ij);
}


float computeLambda(uint i) {
	Particle pi = particles[i];
    if(pi.density == REST_DENSITY) return 0.0;

    float rho0 = REST_DENSITY;
    float sumGradCj = 0;
    vec4 gradCi = vec4(0);
    float density = 0.0;
    
    OVERNNS_I
		Particle pj = particles[j];
        if(pj.phase != FLUID) continue;
  
		vec4 dist = pi.pposition - pj.pposition;
		vec4 gradCj = densityConstraintGradient(pi.pposition, pj.pposition);
		if (j == i) {
			gradCi += gradCj;
		}
		sumGradCj += dot(gradCj, gradCj);
		density += pj.mass * poly6(dist);
	OVERNNS_END

	particles[i].density = density;
    float C = max((density / rho0) - 1, 0.0);
    return -C / (sumGradCj + 1e-6);
}


//Compute position deltas w neigbor
vec4 computePositionDelta(uint i) {
	vec4 posDelta = vec4(0.0f);
	float rho0 = REST_DENSITY;
	Particle pi = particles[i];
	OVERNNS
		Particle pj = particles[j];
		if( pj.phase != FLUID) continue;
		  vec4 dist = pi.pposition - pj.pposition;
          float sCorr = -(pressureMultiplier) * pow(poly6(dist) / poly6(vec4(0.3*H, 0,0,0)), 4);
          vec4 dp_ij = spiky_grad(dist) * ((pi.lambda + pj.lambda  + sCorr ) / rho0);
          posDelta += dp_ij;
	OVERNNS_END
	return posDelta;
}
*/

#endif