#version 430

#pragma once
#include "../common/uniforms.comp"
#include "../common/constants.comp"
#include "../common/buffers.comp"
#include "../common/colors.comp"
#include "../common/nns.comp"
#include "sph.kernels.comp" 
#include "constraint.comp" 

layout (local_size_x = PTHREAD) in;

void SolveFluid(uint i, uint simStep) {
	uint binIndex = getBinIndex(particles[i].pposition);
	switch(simStep){ 
		case 0 : //Bin sorting
			particles[i].binIndex = binIndex;
			atomicAdd(bins[binIndex].count, 1);
			cpy_particles[i] = particles[i];
		break;
		case 1 : //Sort particle indices
			particles[i].binIndex = binIndex;
			uint newID = atomicAdd(bins[binIndex].index, -1) -1;
			particles[newID] = cpy_particles[i];
			sortedIndices[particles[newID].id] = newID;
		break;
		//compute non pressure acceleration
		case 2:
			particles[i].mass = particleMass;
			vec2 acceleration = vec2(0,-g);
			particles[i].pposition = particles[i].position + particles[i].velocity * dt + acceleration * (dt * dt);
		break;
		//compute lagrange multiplier
		case 3 :
			particles[i].lambda = computeLambda(i);
		break;
		//correct density error and update position
		case 4 :
			particles[i].pposition += computePositionDelta(i);
			particles[i].pposition += solveFloorCollision(i);
			//particles[i].pposition = clampPosition(particles[i].pposition);
			particles[i].velocity = 0.99998 * (particles[i].pposition - particles[i].position)/dt;
			particles[i].position = particles[i].pposition;
		break;
		case 5:
			vec2 xsphSum = vec2(0);
			OVERNNS
				Particle pj = particles[j];
				vec2 dist = particles[i].position - particles[j].position;
				vec2 Vij = particles[j].velocity - particles[i].velocity;
				float Wij = cubicKernel2D(dist);
				xsphSum -= alphaVisco * Vij * Wij * particles[j].density;
			OVERNNS_END
			particles[i].velocity -= xsphSum;
		break;
		//End iteration
		
	}

}


uniform uint stage;
uniform vec4 sourcePos;
// XPBD_Main
void main() {
	uint i = gl_GlobalInvocationID.x;
	if (i >= numParticles) return;
	SolveFluid(i, stage);
}