#version 430

#pragma once
#include "../common/uniforms.comp"
#include "../common/constants.comp"
#include "../common/buffers.comp"
#include "../common/colors.comp"
#include "../common/nns.comp"
#include "sph.kernels.comp" 
#include "constraint.comp" 

layout (local_size_x = PTHREAD) in;

void NNS(uint i, uint simStep) {
	uint binIndex = getBinIndex(particles[i].position);
	switch(simStep){ //Neighbor search
		case 0 : //Bin sorting
			atomicAdd(bins[binIndex].count, 1);
			cpy_particles[i] = particles[i];
		break;
		case 1 : //Sort particle indices
		uint newID = atomicAdd(bins[binIndex].index, -1) -1;
		particles[newID] = cpy_particles[i];
		break;
	}
}


void SolveFluid(uint i, uint simStep) {
	switch(simStep){ 
		case 0 :
		break;

		//case 1:
		//Skip step 1 (used for neighboring sort)
		//break;

		//Pressure solver Iteration
		case 3 :
			//vec2 acceleration = vec2(0,-G);
			//particles[i].new_position = particles[i].position + particles[i].velocity * dt + acceleration * (dt * dt);
			//particles[i].density = computeDensity(i);
		break;
		
		case 4 :
			//new_position[i] += computePositionDelta(i);
		break;
		//End iteration
		
		case 5 : //Apply changes
			
			//particles[i].velocity = (particles[i].new_position - particles[i].position)/(dt);
			//particles[i].position = particles[i].new_position;
			//clampToBoundaries(position[i], velocity[i]);


			//particles[i].temperature += computeTemperatureDelta(u);			
			//particles[i].position = particles[i].new_position; //apply new position

		break;
	}

}


uniform uint stage;
uniform vec4 sourcePos;
// XPBD_Main
void main() {
	uint i = gl_GlobalInvocationID.x;
	if (i >= numParticles) return;

	if(stage < 2){ 
		NNS(i, stage);
		return;
	}

	SolveFluid(i, stage);
}