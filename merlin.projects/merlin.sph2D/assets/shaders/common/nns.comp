//? #version 430
#ifndef INCLUDE_NNS_GLSL
#define INCLUDE_NNS_GLSL
//?#include "../common/constants.comp"

struct Bin {
	uint count;
	uint sum;
	uint csum;
	uint index;
};

layout(std430) buffer BinBuffer {
	Bin bins[];
};

uvec2 getBinCoord(vec2 position) {
	position.xy -= boundaryMin;
	uvec2 bin3D = uvec2(position / binSize);
	bin3D.x = max( min(bin3D.x, binMax.x -1), 0);
	bin3D.y = max( min(bin3D.y, binMax.y -1), 0);
	return bin3D;
}

uint getBinIndexFromCoord(uvec2 coord) {
	return (coord.y * binMax.x) + coord.x;
}   

uint getBinIndex(vec2 position) {
	uvec2 bin2D = getBinCoord(position);
    return getBinIndexFromCoord(bin2D);
}

uvec2 getBinCoordFromIndex(uint index) {
	uint y = index / binMax.x;
	uint x = index % binMax.x;
	return uvec2(x, y);
}

#define OVERNNS {\
uint binindex = getBinIndex(particles[i].position);\
uvec2 binIndexVec = getBinCoordFromIndex(binindex);\
ivec2 minBound = max(ivec2(binIndexVec) - 1, ivec2(0));\
ivec2 maxBound = min(ivec2(binIndexVec) + 1, ivec2(binMax) - 1);\
for (int y = minBound.y; y <= maxBound.y; y++) {\
    for (int x = minBound.x; x <= maxBound.x; x++) {\
        uint cindex = getBinIndexFromCoord(uvec2(x, y));\
        if (bins[cindex].count == 0) continue;\
        uint ns = bins[cindex].count;\
        uint st = bins[cindex].sum - ns;\
        for (uint j = st; j < st + min(ns, MAXNN); j++) {\
            if (j == i || j >= numParticles) continue;

#define OVERNNS_END }}}}


#endif// INCLUDE_BUFFERS_HLSL