#version 430

#pragma once
#include "../common/uniforms.comp"
#include "../common/constants.comp"
#include "../common/buffers.comp"
#include "../common/colors.comp"
#include "../common/nns.comp"
#include "sph.kernels.comp" 
#include "constraint.comp" 


layout (local_size_x = PTHREAD) in;
void SolveDEM(uint i, uint simStep);
void NNS(uint i, uint simStep);

uniform uint stage;
uniform float drumSpeed = 20.0;
// XPBD_Main
void main() {
	uint i = gl_GlobalInvocationID.x;
	if (i >= numParticles) return;
	NNS(i, stage);
	if(B_Phase(i) == GRANULAR)	SolveDEM(i, stage);
}

void NNS(uint i, uint simStep){
	if(simStep == 0){ //Bin sorting
		uint bin = B_BinIndex(i) = getBinIndex(Xi);
		atomicAdd(bins[bin].count, 1);
		ssbo_cpy_position[i] = ssbo_position[i];
		ssbo_cpy_pposition[i] = ssbo_pposition[i];
		ssbo_cpy_velocity[i] = ssbo_velocity[i];
		ssbo_cpy_temperature[i] = ssbo_temperature[i];
		ssbo_cpy_meta[i] = ssbo_meta[i];

		return;
	}else if(simStep == 1){//Sort particle indices
		uint newID = atomicAdd(bins[ssbo_cpy_meta[i].y].index, -1) -1;

		ssbo_position[newID]  = ssbo_cpy_position[i];
		ssbo_pposition[newID] = ssbo_cpy_pposition[i];
		ssbo_velocity[newID]  = ssbo_cpy_velocity[i];
		ssbo_temperature[newID]   = ssbo_cpy_temperature[i];
		ssbo_meta[newID]      = ssbo_cpy_meta[i];

		ssbo_meta[ssbo_meta[newID].z].z = newID;
		return;
	}
}


void SolveDEM(uint i, uint simStep) {
	
	if(simStep == 2){
		vec2 acceleration = vec2(0,-g);
		Xi = xi + Vi * dt;
		if(length(Xi - xi) < 0.0001) Xi = xi; //particle sleeping
		Xi += acceleration * dt * dt;

		return;
	}else if(simStep == 5){
		Xi += solveParticleCollision(i);
		vec2 orientedRadius = normalize(Xi)*particleRadius;
		float polarR = distance(Xi + orientedRadius, vec2(0));
		if(polarR >= 150){
			vec3 pos = normalize(vec3(Xi.xy,0));
			float wi = drumSpeed;
			vec3 Vdir = normalize(cross(pos, vec3(0,0,1)));
			Ti += 0.5 * (450 - Ti)*dt;
			Xi += (0.99*(-Vdir.xy * wi * 150 * dt) - (Xi - xi));
			
		}
		return;
	}else if(simStep == 3){
		vec2 position = Xi;

		vec3 corr = vec3(0);
		OVERNNS
			if(length(Rji) < 1e-6 || length(Rji) > particleRadius*1.5 || i == j) continue;
			corr.xy += ((Xj - xj) - (Xi - xi));
			corr.z++;
		OVERNNS_END
		corr.xy = corr.xy / max(corr.z, 1.0);
		Xi += corr.xy;
		return;
	}else if(simStep == 4){
		
		Ti += computeTemperatureDelta(i)*dt;
		Xi += solveFloorCollision(i);

		return;
	}else if(simStep == 6){
		Vi = 0.999*(Xi - xi)/dt;
		xi = Xi;
		return;
	}

}



