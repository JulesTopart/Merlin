//? #version 430
#ifndef INCLUDE_CONSTRAINTS_GLSL
#define INCLUDE_CONSTRAINTS_GLSL

//?#include "../common/uniforms.comp"
//?#include "../common/constants.comp"
//?#include "../common/buffers.comp"
//?#include "../common/nns.comp"
//?#include "sph.kernels.comp" 

float computeTemperatureDelta(uint i) {

	float temperatureDelta = 0.0;
	vec3 position = Xi;
	OVERNNS
		if(j == i || Dij < 1e-3 ) continue;
		float rhoj = Mj / (3.1415926*(4/3)*pow(particleRadius,3));
		float lambda = (kWater / (CpWater * rhoj));
		temperatureDelta += lambda*(Tj-Ti)/(Dij*1e-3);
	OVERNNS_END
	//temperatureDelta /= float(n);
	/*
	if(particles[i].position.z < H/2.0){
		temperatureDelta += kPlateau * (floorTemperature - Ti);
	}*/
	//temperatureDelta += kAmbient * (ambientTemperature - Ti);
	return temperatureDelta;
}

float rand(float n){return 1e-2*fract(sin(n) * 43758.5453123);}

vec3 solveParticleCollision(uint i){
	int n = 0;
	vec3 deltaPosition = vec3(0);
	vec3 position = Xi;
	vec3 pi = position;
	OVERNNS
		if(i == j) continue;
		vec3 pj = Xj;
		if(pi == pj) pj = pj + 1e-4;
		vec3 diff = pi - pj;
		float dist = length(diff);
		if(dist >= 2.1*particleRadius) continue; //Ignore particle that are too far
		float l0 = 2.0*particleRadius;
		float l = dist; // Calculate the current length
		// Calculate the constraint violation
		float C = l - l0 - 0.01*rand(l);

		if( C >= 0) continue;
		// Calculate the gradient of the constraint function
		vec3 gradC = normalize(diff);
		 
		// Calculate the effective mass matrix
		float inverseMass = (1.0/Mi) + (1.0/Mj);
		float compliance = 0.000000001; // Compliance of the constraints
		float deltaLambda = -C / ( inverseMass + (compliance/ (dt * dt)));


		// Calculate and apply the position corrections
		deltaPosition += gradC * deltaLambda * Mi;
		n++;

	OVERNNS_END

	if(n > 1) return deltaPosition/float(n);
	else return deltaPosition;
}

vec3 solveFloorCollision(uint i){
	vec3 correctedPosition = Xi;
	for (int i = 0; i < 3; i++){
		if (correctedPosition[i] - particleRadius <= boundaryMin[i] ){
			correctedPosition[i] = (boundaryMin[i]) + particleRadius;
		}
		else if (correctedPosition[i] + particleRadius >= boundaryMax[i])
		{
			correctedPosition[i] =  boundaryMax[i] - particleRadius;
		}
	}

	return (correctedPosition - Xi);
}


vec3 clampToDomain(vec3 position){
	position.x = max(position.x, boundaryMin.x + particleRadius);
	position.x = min(position.x, boundaryMax.x - particleRadius);
	position.y = max(position.y, boundaryMin.y + particleRadius);
	position.y = min(position.y, boundaryMax.y - particleRadius);
	position.z = max(position.z, boundaryMin.z + particleRadius);
	position.z = min(position.z, boundaryMax.z - particleRadius);
	return position;
}





#endif