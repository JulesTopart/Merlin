#version 430

#pragma once
#include "../common/uniforms.comp"
#include "../common/constants.comp"
#include "../common/buffers.comp"
#include "../common/colors.comp"
#include "../common/nns.comp"
#include "sph.kernels.comp" 
#include "constraint.comp" 


layout (local_size_x = PTHREAD) in;
void SolveFluid(uint i, uint simStep);
void NNS(uint i, uint simStep);

uniform uint stage;
uniform vec4 sourcePos;
// XPBD_Main
void main() {
	uint i = gl_GlobalInvocationID.x;
	if (i >= numParticles) return;
	NNS(i, stage);
	if(particles[i].meta.x != BOUNDARY)	SolveFluid(i, stage);
}

void NNS(uint i, uint simStep){
	if(simStep == 0){ //Bin sorting
		particles[i].meta.y = getBinIndex(Xi);
		atomicAdd(bins[particles[i].meta.y].count, 1);
		particles[i].meta.z = 0;
		cpy_particles[i] = particles[i];
		return;
	}
	if(simStep == 1){//Sort particle indices
		uint newID = atomicAdd(bins[cpy_particles[i].meta.y].index, -1) -1;
		particles[newID] = cpy_particles[i];
		sortedIndices[particles[newID].meta.z] = newID;
		return;
	}
}

void SolveFluid(uint i, uint simStep) {
	
	if(simStep == 2){
		vec2 acceleration = vec2(0,-g);
		Vi += acceleration * dt;
		Xi = xi + Vi * dt;
		return;
	}

		
	if(simStep == 3){ //compute lagrange multiplier
		Lambi = computeLambda(i);
		return;
	}
		
	if(simStep == 4){//correct density error and update position
		Xi += computePositionDelta(i);
		Xi += solveFloorCollision(i);
		//particles[i].pposition = clampToDomain(particles[i].pposition);
		return;
	}
	if(simStep == 5){//apply XSPH velocity correction
		Vi = (Xi - xi)/dt;

		vec2 xsphSum = vec2(0);

		vec2 position = Xi;
		OVERNNS
			vec2 dist = Rji;
			float Wij = cubicKernel2D(length(dist));
			xsphSum -= artificialViscosityMultiplier * Vij * Wij * Rhoj;
		OVERNNS_END
		Vi -= xsphSum;

		xi = Xi;
		return;
	}

}

